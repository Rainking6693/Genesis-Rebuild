"\"\"\"Memori-backed reasoning codebook manager for Genesis agents.\"\"\"\n+\n+from __future__ import annotations\n+\n+import hashlib\n+import logging\n+from dataclasses import dataclass\n+from typing import List, Optional\n+\n+from infrastructure.memory.memori_client import MemoriClient\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class CodebookEntry:\n+    id: str\n+    snippet: str\n+    tags: List[str]\n+    agent_id: str\n+    timestamp: str\n+\n+\n+class CodebookManager:\n+    def __init__(self, namespace: str = \"codebook\") -> None:\n+        self.namespace = namespace\n+        self.client = MemoriClient()\n+\n+    def _make_key(self, agent_id: str, snippet: str) -> str:\n+        digest = hashlib.sha256(snippet.encode(\"utf-8\")).hexdigest()\n+        return f\"codebook::{agent_id}::{digest}\"\n+\n+    def store_snippet(self, agent_id: str, snippet: str, tags: Optional[List[str]] = None) -> CodebookEntry:\n+        tags = tags or []\n+        key = self._make_key(agent_id, snippet)\n+        record = self.client.upsert_memory(\n+            namespace=self.namespace,\n+            subject=agent_id,\n+            key=key,\n+            value={\"snippet\": snippet, \"tags\": tags},\n+            metadata={\"tags\": tags},\n+        )\n+        logger.debug(\"Stored codebook snippet %s for %s\", key, agent_id)\n+        return CodebookEntry(\n+            id=key,\n+            snippet=snippet,\n+            tags=tags,\n+            agent_id=agent_id,\n+            timestamp=record.created_at.isoformat(),\n+        )\n+\n+    def retrieve_snippets(self, agent_id: str, tags: Optional[List[str]] = None, limit: int = 3) -> List[CodebookEntry]:\n+        records = self.client.list_memory(self.namespace, subject=agent_id)\n+        filtered: List[CodebookEntry] = []\n+        tag_set = set((tag or \"\").lower() for tag in (tags or []))\n+        for record in records:\n+            payload = record.value or {}\n+            snippet = payload.get(\"snippet\", \"\")\n+            entry_tags = [t.lower() for t in (payload.get(\"tags\") or [])]\n+            if tag_set and not tag_set.intersection(entry_tags):\n+                continue\n+            filtered.append(\n+                CodebookEntry(\n+                    id=record.key,\n+                    snippet=snippet,\n+                    tags=payload.get(\"tags\", []),\n+                    agent_id=agent_id,\n+                    timestamp=record.created_at.isoformat(),\n+                )\n+            )\n+            if len(filtered) >= limit:\n+                break\n+        return filtered\n*** End Patch**
