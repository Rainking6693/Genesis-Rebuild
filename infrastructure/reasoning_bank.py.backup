"""
ReasoningBank - Shared Memory & Collective Intelligence System
Layer 6 implementation for Genesis multi-agent system

Three-tier memory system:
1. Consensus Memory: Verified team procedures and successful patterns
2. Persona Library: Agent characteristics, specializations, performance metrics
3. Whiteboard Memory: Shared working spaces for collaborative tasks

Implements strategy distillation from both successful and failed trajectories.
Supports Memory-Aware Test-Time Scaling (MaTTS) with contrastive evaluation.
"""

import json
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from enum import Enum
import hashlib

try:
    from pymongo import MongoClient
    from pymongo.errors import ConnectionFailure
    MONGO_AVAILABLE = True
except ImportError:
    MONGO_AVAILABLE = False
    print("âš ï¸  MongoDB not available - using in-memory storage")

try:
    import redis
    REDIS_AVAILABLE = True
except ImportError:
    REDIS_AVAILABLE = False
    print("âš ï¸  Redis not available - using in-memory cache")


class MemoryType(Enum):
    """Types of memory in the ReasoningBank"""
    CONSENSUS = "consensus"  # Verified procedures
    PERSONA = "persona"      # Agent profiles
    WHITEBOARD = "whiteboard"  # Collaborative workspace
    STRATEGY = "strategy"    # Distilled strategies


class OutcomeTag(Enum):
    """Outcome tags for contrastive evaluation"""
    SUCCESS = "success"
    FAILURE = "failure"
    PARTIAL = "partial"
    UNKNOWN = "unknown"


@dataclass
class MemoryEntry:
    """Base memory entry structure"""
    memory_id: str
    memory_type: MemoryType
    content: Dict[str, Any]
    metadata: Dict[str, Any]
    outcome: OutcomeTag
    win_rate: float  # 0.0 to 1.0
    usage_count: int
    created_at: str
    updated_at: str
    tags: List[str]


@dataclass
class StrategyNugget:
    """Distilled strategy from successful/failed trajectories"""
    strategy_id: str
    description: str
    context: str  # When to use this strategy
    task_metadata: Dict[str, Any]
    environment: str
    tools_used: List[str]
    outcome: OutcomeTag
    win_rate: float
    steps: List[str]
    learned_from: List[str]  # Source trajectory IDs
    created_at: str


@dataclass
class AgentPersona:
    """Agent characteristics and specializations"""
    agent_id: str
    agent_name: str
    specialization: str
    capabilities: List[str]
    success_rate: float
    total_tasks: int
    successful_tasks: int
    average_cost: float  # Token cost per task
    preferred_models: List[str]
    performance_metrics: Dict[str, float]
    created_at: str
    updated_at: str


class ReasoningBank:
    """
    Shared memory system for multi-agent collective intelligence

    Optimizes KV-cache hits and reduces the 15x token multiplier problem
    documented in MongoDB's multi-agent memory research.
    """

    def __init__(
        self,
        mongo_uri: str = "mongodb://localhost:27017/",
        redis_host: str = "localhost",
        redis_port: int = 6379,
        db_name: str = "genesis_reasoning_bank"
    ):
        self.db_name = db_name
        self.in_memory_store: Dict[str, MemoryEntry] = {}
        self.in_memory_strategies: Dict[str, StrategyNugget] = {}
        self.in_memory_personas: Dict[str, AgentPersona] = {}

        # MongoDB setup
        if MONGO_AVAILABLE:
            try:
                self.mongo_client = MongoClient(mongo_uri, serverSelectionTimeoutMS=5000)
                # Test connection
                self.mongo_client.admin.command('ping')
                self.db = self.mongo_client[db_name]
                self.memories = self.db.memories
                self.strategies = self.db.strategies
                self.personas = self.db.personas
                self.mongo_available = True
                print(f"âœ… ReasoningBank connected to MongoDB: {db_name}")
            except (ConnectionFailure, Exception) as e:
                print(f"âš ï¸  MongoDB connection failed: {e}")
                print("   Using in-memory storage instead")
                self.mongo_available = False
        else:
            self.mongo_available = False

        # Redis setup for caching
        if REDIS_AVAILABLE:
            try:
                self.redis_client = redis.Redis(
                    host=redis_host,
                    port=redis_port,
                    decode_responses=True,
                    socket_connect_timeout=5
                )
                self.redis_client.ping()
                self.redis_available = True
                print(f"âœ… ReasoningBank connected to Redis cache")
            except (redis.ConnectionError, Exception) as e:
                print(f"âš ï¸  Redis connection failed: {e}")
                print("   Caching disabled")
                self.redis_available = False
        else:
            self.redis_available = False

    def _generate_id(self, content: str) -> str:
        """Generate unique ID from content"""
        return hashlib.sha256(content.encode()).hexdigest()[:16]

    def store_memory(
        self,
        memory_type: MemoryType,
        content: Dict[str, Any],
        metadata: Dict[str, Any],
        outcome: OutcomeTag = OutcomeTag.UNKNOWN,
        tags: List[str] = None
    ) -> str:
        """Store a memory entry"""
        memory_id = self._generate_id(json.dumps(content))
        now = datetime.now(timezone.utc).isoformat()

        entry = MemoryEntry(
            memory_id=memory_id,
            memory_type=memory_type,
            content=content,
            metadata=metadata,
            outcome=outcome,
            win_rate=0.0,
            usage_count=0,
            created_at=now,
            updated_at=now,
            tags=tags or []
        )

        if self.mongo_available:
            self.memories.insert_one(asdict(entry))
        else:
            self.in_memory_store[memory_id] = entry

        # Cache in Redis
        if self.redis_available:
            self.redis_client.setex(
                f"memory:{memory_id}",
                3600,  # 1 hour TTL
                json.dumps(asdict(entry))
            )

        return memory_id

    def store_strategy(
        self,
        description: str,
        context: str,
        task_metadata: Dict[str, Any],
        environment: str,
        tools_used: List[str],
        outcome: OutcomeTag,
        steps: List[str],
        learned_from: List[str]
    ) -> str:
        """Store a distilled strategy nugget"""
        strategy_id = self._generate_id(f"{description}:{context}")
        now = datetime.now(timezone.utc).isoformat()

        strategy = StrategyNugget(
            strategy_id=strategy_id,
            description=description,
            context=context,
            task_metadata=task_metadata,
            environment=environment,
            tools_used=tools_used,
            outcome=outcome,
            win_rate=0.0,
            steps=steps,
            learned_from=learned_from,
            created_at=now
        )

        if self.mongo_available:
            self.strategies.insert_one(asdict(strategy))
        else:
            self.in_memory_strategies[strategy_id] = strategy

        return strategy_id

    def store_persona(self, persona: AgentPersona) -> str:
        """Store or update agent persona"""
        if self.mongo_available:
            self.personas.update_one(
                {"agent_id": persona.agent_id},
                {"$set": asdict(persona)},
                upsert=True
            )
        else:
            self.in_memory_personas[persona.agent_id] = persona

        return persona.agent_id

    def get_memory(self, memory_id: str) -> Optional[MemoryEntry]:
        """Retrieve a memory entry"""
        # Check Redis cache first
        if self.redis_available:
            cached = self.redis_client.get(f"memory:{memory_id}")
            if cached:
                data = json.loads(cached)
                data['memory_type'] = MemoryType(data['memory_type'])
                data['outcome'] = OutcomeTag(data['outcome'])
                return MemoryEntry(**data)

        # Check MongoDB
        if self.mongo_available:
            data = self.memories.find_one({"memory_id": memory_id})
            if data:
                data.pop('_id', None)
                data['memory_type'] = MemoryType(data['memory_type'])
                data['outcome'] = OutcomeTag(data['outcome'])
                return MemoryEntry(**data)
        else:
            return self.in_memory_store.get(memory_id)

        return None

    def search_strategies(
        self,
        task_context: str,
        top_n: int = 5,
        min_win_rate: float = 0.5
    ) -> List[StrategyNugget]:
        """
        Search for relevant strategies (MaTTS pattern)
        Returns top-N strategies with highest win rates
        """
        if self.mongo_available:
            results = self.strategies.find({
                "context": {"$regex": task_context, "$options": "i"},
                "win_rate": {"$gte": min_win_rate}
            }).sort("win_rate", -1).limit(top_n)

            strategies = []
            for data in results:
                data.pop('_id', None)
                data['outcome'] = OutcomeTag(data['outcome'])
                strategies.append(StrategyNugget(**data))
            return strategies
        else:
            # In-memory search
            matched = [
                s for s in self.in_memory_strategies.values()
                if task_context.lower() in s.context.lower() and s.win_rate >= min_win_rate
            ]
            return sorted(matched, key=lambda x: x.win_rate, reverse=True)[:top_n]

    def get_agent_persona(self, agent_id: str) -> Optional[AgentPersona]:
        """Retrieve agent persona"""
        if self.mongo_available:
            data = self.personas.find_one({"agent_id": agent_id})
            if data:
                data.pop('_id', None)
                return AgentPersona(**data)
        else:
            return self.in_memory_personas.get(agent_id)

        return None

    def update_strategy_outcome(
        self,
        strategy_id: str,
        success: bool
    ):
        """Update strategy win rate based on outcome (contrastive evaluation)"""
        if self.mongo_available:
            strategy_data = self.strategies.find_one({"strategy_id": strategy_id})
            if strategy_data:
                usage_count = strategy_data.get('usage_count', 0) + 1
                successes = strategy_data.get('successes', 0) + (1 if success else 0)
                win_rate = successes / usage_count

                self.strategies.update_one(
                    {"strategy_id": strategy_id},
                    {"$set": {
                        "win_rate": win_rate,
                        "usage_count": usage_count,
                        "successes": successes
                    }}
                )
        else:
            strategy = self.in_memory_strategies.get(strategy_id)
            if strategy:
                usage_count = getattr(strategy, 'usage_count', 0) + 1
                successes = getattr(strategy, 'successes', 0) + (1 if success else 0)
                strategy.win_rate = successes / usage_count
                setattr(strategy, 'usage_count', usage_count)
                setattr(strategy, 'successes', successes)

    def prune_low_performing_strategies(self, threshold: float = 0.3):
        """Remove strategies with win rates below threshold"""
        if self.mongo_available:
            result = self.strategies.delete_many({"win_rate": {"$lt": threshold}})
            print(f"ğŸ—‘ï¸  Pruned {result.deleted_count} low-performing strategies (< {threshold} win rate)")
        else:
            before = len(self.in_memory_strategies)
            self.in_memory_strategies = {
                k: v for k, v in self.in_memory_strategies.items()
                if v.win_rate >= threshold
            }
            pruned = before - len(self.in_memory_strategies)
            print(f"ğŸ—‘ï¸  Pruned {pruned} low-performing strategies (< {threshold} win rate)")

    def get_consensus_memory(self, tags: List[str] = None) -> List[MemoryEntry]:
        """Get consensus memories (verified procedures)"""
        query = {"memory_type": MemoryType.CONSENSUS.value}
        if tags:
            query["tags"] = {"$in": tags}

        if self.mongo_available:
            results = self.memories.find(query).sort("win_rate", -1)
            memories = []
            for data in results:
                data.pop('_id', None)
                data['memory_type'] = MemoryType(data['memory_type'])
                data['outcome'] = OutcomeTag(data['outcome'])
                memories.append(MemoryEntry(**data))
            return memories
        else:
            return [
                m for m in self.in_memory_store.values()
                if m.memory_type == MemoryType.CONSENSUS and
                (not tags or any(t in m.tags for t in tags))
            ]

    def close(self):
        """Clean up connections"""
        if self.mongo_available:
            self.mongo_client.close()
        if self.redis_available:
            self.redis_client.close()


# Singleton instance
_reasoning_bank_instance: Optional[ReasoningBank] = None


def get_reasoning_bank() -> ReasoningBank:
    """Get or create ReasoningBank singleton"""
    global _reasoning_bank_instance
    if _reasoning_bank_instance is None:
        _reasoning_bank_instance = ReasoningBank()
    return _reasoning_bank_instance
