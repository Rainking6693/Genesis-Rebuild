# Content Agent - DeepResearch Training Data Generation Template

## Agent Role
You are a Content Creation and Marketing Specialist. Your expertise includes blog writing, social media content, email campaigns, technical documentation, SEO optimization, and brand storytelling. You help organizations communicate effectively with their audiences through high-quality written content.

## Task Categories

1. **Blog Writing** - Long-form articles, thought leadership, tutorials, case studies
2. **Social Media Content** - Posts, captions, threads, community engagement
3. **Email Campaigns** - Newsletters, drip campaigns, promotional emails, cold outreach
4. **Technical Documentation** - API docs, user guides, README files, release notes
5. **SEO & Copy** - Landing page copy, meta descriptions, product descriptions, headlines

## Example Tasks (10-15 diverse scenarios)

### Easy Tasks (30%)
1. Write a 280-character Twitter post announcing a new product feature (dark mode)
2. Create a subject line and preview text for a newsletter about a webinar (50 registrations goal)
3. Write a product description for an e-commerce listing (wireless headphones, 150 words)
4. Draft a README file for a simple Python library (installation, usage example, license)
5. Create 3 headline variations for a landing page promoting a project management tool

### Medium Tasks (45%)
6. Write a 1,000-word blog post: "10 Best Practices for API Security" targeting backend developers (include code examples, real-world incidents, actionable tips)
7. Create a 5-email drip campaign for trial users of a SaaS product (Day 1: Welcome, Day 3: Feature highlight, Day 7: Case study, Day 14: Upgrade offer, Day 21: Last chance)
8. Draft a Twitter thread (10 tweets) explaining a complex technical concept (how LLMs work) for non-technical audience
9. Write landing page copy for a B2B sales automation tool (hero, problem, solution, features, pricing, CTA) targeting sales managers
10. Create technical documentation for a REST API endpoint (POST /api/orders): authentication, request/response schemas, error codes, rate limits, code examples in 3 languages
11. Write a case study (1,200 words) about how a customer achieved 10X ROI using your product (challenge, solution, results, testimonial)
12. Draft a cold outreach email sequence (3 emails over 2 weeks) for B2B SaaS selling to HR managers

### Hard Tasks (25%)
13. Write a comprehensive white paper (3,000 words) on "The Future of AI in Healthcare" including market trends, technology analysis, regulatory considerations, case studies, and strategic recommendations
14. Create a full content marketing strategy for a startup entering a crowded market (competitor analysis, content pillars, SEO keywords, distribution channels, 90-day editorial calendar)
15. Write a technical blog post (2,500 words) explaining a complex algorithm (Raft consensus) with interactive diagrams, pseudocode, and production implementation considerations
16. Draft a crisis communication plan and initial response for a data breach affecting 100K customers (internal memo, customer email, press release, FAQ, social media posts)
17. Create a complete API documentation site structure for a complex platform (15+ endpoints, authentication, webhooks, SDKs, tutorials, migration guides)

## Quality Criteria

**Specificity:** Each generated task should include concrete details (audience, word count, format, goals, constraints)

**Complexity:**
- Easy: Single piece of content, clear format, straightforward message, <300 words
- Medium: Multi-part content, some research required, specific audience, 800-1,500 words
- Hard: Comprehensive content, deep research, multiple formats, strategic planning, 2,000+ words

**Realism:** Tasks should reflect real-world content creation:
- Actual content types (blog, email, docs, landing page, social media)
- Real business goals (conversions, engagement, SEO ranking, user education)
- Specific audiences (developers, marketers, executives, end-users)
- Constraints (word count, brand voice, SEO keywords, technical accuracy)

**Diversity:** Cover all 5 task categories across different:
- Content formats (long-form, short-form, technical, creative, persuasive)
- Audiences (B2B, B2C, technical, non-technical, executives, end-users)
- Goals (awareness, consideration, conversion, retention, education)
- Industries (SaaS, e-commerce, healthcare, fintech, dev tools)

## Output Format (JSON)

```json
{
  "task": "Write a 1,000-word blog post on API security best practices for backend developers",
  "context": "You're writing for a developer tools company's engineering blog. Target audience: Backend developers (Python, Node.js, Go) building REST APIs for production. Goals: (1) Establish thought leadership, (2) Drive traffic from Google search ('API security best practices'), (3) Generate newsletter signups (CTA at bottom). Tone: Technical but accessible, practical over theoretical. Include: Real-world examples, code snippets, specific tools/libraries, actionable checklist. Avoid: Marketing fluff, outdated practices (MD5 hashing), overly basic advice ('use HTTPS').",
  "expected_output": "# 10 API Security Best Practices Every Backend Developer Should Know (2025)\n\n*Data breaches via insecure APIs cost companies $4.24M on average. Here's how to protect your endpoints from authentication bypass, injection attacks, and rate limit abuse.*\n\n---\n\n## Introduction\n\nIn March 2024, a misconfigured API at a major healthcare provider exposed 3.5 million patient records. The culprit? A missing authentication check on a single admin endpoint. This isn't an isolated incident—API vulnerabilities accounted for 42% of all security incidents in 2024 (Verizon DBIR).\n\nAs APIs become the backbone of modern applications, securing them is no longer optional. This guide covers 10 battle-tested practices that will harden your APIs against the most common attack vectors.\n\n---\n\n## 1. Implement Token-Based Authentication (OAuth 2.0 + JWT)\n\n**Why it matters:** Basic Auth credentials can be intercepted. Stateful sessions don't scale in microservices.\n\n**Best practice:** Use OAuth 2.0 for authorization + JWT for stateless authentication.\n\n```python\n# Python (FastAPI) example\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nimport jwt\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef verify_token(token: str = Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n@app.get(\"/api/protected\")\nasync def protected_route(user: dict = Depends(verify_token)):\n    return {\"message\": f\"Hello {user['username']}\"}\n```\n\n**Key considerations:**\n- Use short-lived access tokens (15 min) + long-lived refresh tokens\n- Store refresh tokens in httpOnly cookies (never localStorage)\n- Rotate secrets regularly (30-90 days)\n\n**Tools:** Auth0, Keycloak, AWS Cognito, or self-hosted solutions like `python-jose`\n\n---\n\n## 2. Rate Limit Everything (Token Bucket Algorithm)\n\n**Why it matters:** Prevents brute-force attacks, DDoS, and API abuse that can cost you $$$ in compute.\n\n**Example attack:** 10,000 requests/second to your login endpoint trying common passwords.\n\n**Best practice:** Implement tiered rate limiting:\n- Per IP: 100 requests/minute (unauthenticated)\n- Per user: 1,000 requests/minute (authenticated)\n- Per endpoint: 10 requests/minute (sensitive ops like password reset)\n\n```python\n# Using Redis + token bucket\nfrom redis import Redis\nimport time\n\nredis = Redis()\n\ndef check_rate_limit(key: str, limit: int, window: int) -> bool:\n    current = redis.get(key)\n    if current is None:\n        redis.setex(key, window, 1)\n        return True\n    if int(current) >= limit:\n        return False\n    redis.incr(key)\n    return True\n\n# Usage\nif not check_rate_limit(f\"rate_limit:{user_id}\", limit=1000, window=60):\n    raise HTTPException(status_code=429, detail=\"Too many requests\")\n```\n\n**Tools:** Redis, nginx rate limiting, Cloudflare, API gateways (Kong, Tyk)\n\n---\n\n## 3. Validate Input Aggressively (Parameterized Queries + Schema Validation)\n\n**Why it matters:** SQL injection, NoSQL injection, XSS, and command injection all stem from trusting user input.\n\n**Real-world incident:** In 2023, a API endpoint accepting raw SQL in a 'sort' parameter led to database dump.\n\n**Best practice:**\n- Use ORMs with parameterized queries (NEVER string concatenation)\n- Validate request schemas with Pydantic/Zod/Joi\n- Sanitize output (encode HTML, strip scripts)\n\n```python\n# Vulnerable (DON'T DO THIS)\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"  # ⚠️ SQL injection\n\n# Secure (parameterized query)\nquery = \"SELECT * FROM users WHERE id = %s\"\ncursor.execute(query, (user_id,))\n\n# Request validation with Pydantic\nfrom pydantic import BaseModel, EmailStr, constr\n\nclass CreateUserRequest(BaseModel):\n    email: EmailStr  # Validates email format\n    password: constr(min_length=8, max_length=100)  # Length limits\n    username: constr(regex=\"^[a-zA-Z0-9_]+$\")  # Alphanumeric only\n\n@app.post(\"/api/users\")\nasync def create_user(request: CreateUserRequest):  # Auto-validated\n    # request.email is guaranteed valid\n    pass\n```\n\n**Checklist:**\n- ✅ Whitelist allowed input (not blacklist)\n- ✅ Enforce type safety (int, email, UUID, etc.)\n- ✅ Set length limits (prevent DoS via huge payloads)\n- ✅ Escape output in responses\n\n---\n\n## 4. Use HTTPS Everywhere + HSTS\n\n**Why it matters:** Prevents man-in-the-middle attacks, credential sniffing, session hijacking.\n\n**Best practice:**\n- Obtain TLS certificates (Let's Encrypt is free)\n- Enable HSTS header (force HTTPS for 1 year)\n- Redirect HTTP → HTTPS (301 permanent)\n\n```python\n# FastAPI example\nfrom fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\n\napp.add_middleware(HTTPSRedirectMiddleware)\napp.add_middleware(\n    TrustedHostMiddleware,\n    allowed_hosts=[\"api.example.com\"]\n)\n\n# Add HSTS header\n@app.middleware(\"http\")\nasync def add_hsts_header(request, call_next):\n    response = await call_next(request)\n    response.headers[\"Strict-Transport-Security\"] = \"max-age=31536000; includeSubDomains\"\n    return response\n```\n\n**Bonus:** Enable Certificate Transparency monitoring (crt.sh) to detect unauthorized cert issuance.\n\n---\n\n## 5. Implement Least Privilege Access (RBAC + Scopes)\n\n**Why it matters:** A compromised customer support token shouldn't have delete-all-data permissions.\n\n**Best practice:** Use Role-Based Access Control (RBAC) with fine-grained scopes:\n- Admin: `users:read`, `users:write`, `users:delete`\n- Support: `users:read`, `tickets:write`\n- Customer: `profile:read`, `profile:write`\n\n```python\nfrom functools import wraps\n\ndef require_scope(required_scope: str):\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, user: dict = Depends(verify_token), **kwargs):\n            if required_scope not in user.get(\"scopes\", []):\n                raise HTTPException(status_code=403, detail=\"Insufficient permissions\")\n            return await func(*args, user=user, **kwargs)\n        return wrapper\n    return decorator\n\n@app.delete(\"/api/users/{user_id}\")\n@require_scope(\"users:delete\")\nasync def delete_user(user_id: int, user: dict):\n    # Only users with users:delete scope can call this\n    pass\n```\n\n**Tip:** Never use a single \"admin\" boolean. Use granular permissions.\n\n---\n\n## 6-10. [Additional Sections]\n\n6. Log Everything (But Redact PII)\n7. Implement API Versioning (Breaking Changes)\n8. Use Secrets Management (Vault, AWS Secrets Manager)\n9. Enable CORS Carefully (Not `Access-Control-Allow-Origin: *`)\n10. Monitor for Anomalies (Unusual traffic patterns)\n\n---\n\n## Conclusion: Your API Security Checklist\n\n✅ Token-based auth (OAuth 2.0 + JWT)  \n✅ Rate limiting (100-1000 req/min)  \n✅ Input validation (Pydantic schemas)  \n✅ HTTPS + HSTS headers  \n✅ Least privilege RBAC  \n✅ Audit logging (redacted PII)  \n✅ API versioning (/v1, /v2)  \n✅ Secrets in Vault (not .env)  \n✅ Restrictive CORS policies  \n✅ Anomaly detection monitoring  \n\n**Next steps:** Run an API security audit using tools like OWASP ZAP, Burp Suite, or automated scanners (42Crunch, StackHawk).\n\n---\n\n**Want to level up your API security?** [Subscribe to our newsletter](#) for weekly deep dives on backend engineering best practices.\n\n*Written by [Your Name] | Published: March 15, 2025*",
  "tools_used": ["search", "visit", "scholar"],
  "difficulty": "medium",
  "agent_name": "content_agent",
  "task_category": "blog_writing"
}
```

## Generation Instructions

When using DeepResearch (Tongyi-DeepResearch-30B-A3B) to generate training examples:

1. **Use ReAct Mode (70% of examples):**
   - Thought → Action → Observation loops
   - Search for industry trends, statistics, best practices, competitor content
   - Visit authoritative sources (official docs, research papers, case studies)
   - Generate well-researched, data-backed content

2. **Use IterResearch Mode (30% of examples):**
   - For complex/hard tasks requiring deeper research
   - n=3 rollouts with fusion for comprehensive content
   - Example: White papers, technical deep dives, competitive analysis

3. **Ensure Diversity:**
   - Rotate through all 5 task categories
   - Mix content lengths (tweets → blog posts → white papers)
   - Vary tones (casual, professional, technical, persuasive)
   - Include both creative and analytical content

4. **Validate Quality:**
   - Content should be original, not plagiarized
   - Include specific examples, statistics, code snippets
   - Follow content best practices (hook, structure, CTA)
   - Match specified tone and audience
   - Optimize for goals (SEO, conversions, education)

## Target Distribution for Content Agent

- **Total Examples:** 1,333 (out of 20,000 across all 15 agents)
- **Easy:** 400 examples (30%)
- **Medium:** 600 examples (45%)
- **Hard:** 333 examples (25%)
- **ReAct Mode:** 933 examples (70%)
- **IterResearch Mode:** 400 examples (30%)

## Integration with Unsloth Pipeline

Generated examples will be converted to Unsloth format:
```json
{
  "instruction": "<task from above>",
  "input": "<context from above>",
  "output": "<expected_output from above>"
}
```

These will be used to fine-tune Genesis Content agent for improved writing capabilities.

## Content Quality Checklist

**Structure:**
- Clear headline (H1) with benefit/hook
- Introduction (problem + why it matters)
- Body (numbered sections, examples, visuals)
- Conclusion (summary + CTA)

**Style:**
- Active voice ("Use OAuth 2.0" not "OAuth 2.0 should be used")
- Short paragraphs (2-3 sentences max)
- Bullet points for scannability
- Code blocks with syntax highlighting

**SEO:**
- Target keyword in headline, first 100 words, H2s
- Meta description (150-160 chars)
- Internal/external links (3-5)
- Alt text for images

**Engagement:**
- Hook in first 2 sentences
- Specific examples/numbers (not vague)
- Actionable takeaways
- Clear CTA at end
