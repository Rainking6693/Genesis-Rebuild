1.  **Code Generation:** I will generate the `stripe_billing` component, focusing on key functionalities like subscription management, payment processing, and webhook handling. I will use TypeScript and React, as demonstrated in the example. The code will include robust error handling and utilize error boundary patterns.
2.  **Code Quality:** I will aim for high test coverage and type coverage, drawing from the `code_quality` memory.
3.  **Build Report:** I will create a detailed build report, including the status, language, lines of code, test coverage, type coverage, errors, and warnings.

Now, let's generate the code.

# Generate stripe_billing component
write(
    content='// src/components/StripeBilling.tsx\nimport React, { useState, useEffect } from \'react\';\nimport { loadStripe } from \'@stripe/stripe-js\';\n\ninterface StripeBillingProps {\n  customerId: string;\n}\n\nconst StripeBilling: React.FC<StripeBillingProps> = ({ customerId }) => {\n  const [stripe, setStripe] = useState<stripe.Stripe | null>(null);\n  const [subscriptionStatus, setSubscriptionStatus] = useState<string | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n\n  useEffect(() => {\n    const initializeStripe = async () => {\n      try {\n        const stripeInstance = await loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY || \'\');\n        if (stripeInstance) {\n          setStripe(stripeInstance);\n        } else {\n          setError(\'Failed to initialize Stripe.\');\n        }\n      } catch (err: any) {\n        setError(`Error initializing Stripe: ${err.message}`);\n      }\n    };\n\n    initializeStripe();\n  }, []);\n\n  useEffect(() => {\n    if (stripe && customerId) {\n      const fetchSubscriptionStatus = async () => {\n        setLoading(true);\n        try {\n          const response = await fetch(\'/api/stripe/subscription-status\', {\n            method: \'POST\',\n            headers: {\n              \'Content-Type\': \'application/json\',\n            },\n            body: JSON.stringify({ customerId }),\n          });\n\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n\n          const data = await response.json();\n          setSubscriptionStatus(data.status);\n        } catch (err: any) {\n          setError(`Error fetching subscription status: ${err.message}`);\n        } finally {\n          setLoading(false);\n        }\n      };\n\n      fetchSubscriptionStatus();\n    }\n  }, [stripe, customerId]);\n\n  const handleUpgradeSubscription = async () => {\n    try {\n      const response = await fetch(\'/api/stripe/create-checkout-session\', {\n        method: \'POST\',\n        headers: {\n          \'Content-Type\': \'application/json\',\n        },\n        body: JSON.stringify({ customerId, priceId: \'YOUR_PREMIUM_PRICE_ID\' }), // Replace with actual price ID\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      if (data.sessionId) {\n        stripe?.redirectToCheckout({ sessionId: data.sessionId });\n      } else {\n        setError(\'Failed to create checkout session.\');\n      }\n    } catch (err: any) {\n      setError(`Error creating checkout session: ${err.message}`);\n    }\n  };\n\n  if (loading) {\n    return <div>Loading subscription status...</div>;\n  }\n\n  if (error) {\n    return <div>Error: {error}</div>;\n  }\n\n  return (\n    <div>\n      <h2>Subscription Status: {subscriptionStatus || \'Not subscribed\'}</h2>\n      {subscriptionStatus !== \'active\' && (\n        <button onClick={handleUpgradeSubscription}>Upgrade Subscription</button>\n      )}\n    </div>\n  );\n};\n\nexport default StripeBilling;\n',
    file_path='src/components/StripeBilling.tsx'
)